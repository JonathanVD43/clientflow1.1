// src/lib/db/clients.ts
import { requireUser } from "@/lib/auth/require-user";
import { assertUuid } from "@/lib/validation/uuid";
import { expectSingleId } from "@/lib/db/query-builder";

export async function listClients() {
  const { supabase, user } = await requireUser();

  // ✅ defense-in-depth: even if you accidentally bypass RLS elsewhere,
  // this query still only fetches the signed-in user's rows.
  const { data, error } = await supabase
    .from("clients")
    .select(
      "id,name,email,active,portal_enabled,public_token,created_at,updated_at"
    )
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data ?? [];
}

export async function createClient(input: {
  name: string;
  email?: string | null;
  phone_number?: string | null;
}) {
  const { supabase, user } = await requireUser();

  return expectSingleId(
    supabase
      .from("clients")
      .insert({
        user_id: user.id,
        name: input.name.trim(),
        email: input.email?.trim() || null,
        phone_number: input.phone_number?.trim() || null,
        // public_token generated by DB default
      })
      .select("id")
      .single(),
    "Insert succeeded but no id returned"
  );
}

export async function getClient(clientId: string) {
  assertUuid("clientId", clientId);

  const { supabase, user } = await requireUser();

  const { data, error } = await supabase
    .from("clients")
    .select(
      "id,name,email,phone_number,active,portal_enabled,public_token,notify_by_email,due_day_of_month,due_timezone,created_at,updated_at"
    )

    .eq("id", clientId)
    .eq("user_id", user.id) // ✅ defense-in-depth + matches RLS intent
    .single();

  if (error) throw error;
  return data;
}

export async function updateClient(
  clientId: string,
  patch: {
    name?: string;
    email?: string | null;
    phone_number?: string | null;
    active?: boolean;
    portal_enabled?: boolean;
    notify_by_email?: boolean;
    due_day_of_month?: number;
    due_timezone?: string;
  }
) {
  assertUuid("clientId", clientId);

  const { supabase, user } = await requireUser();

  const update: Record<string, unknown> = {};
  if (typeof patch.name === "string") update.name = patch.name.trim();
  if ("email" in patch) update.email = patch.email ? patch.email.trim() : null;
  if ("phone_number" in patch)
    update.phone_number = patch.phone_number ? patch.phone_number.trim() : null;
  if (typeof patch.active === "boolean") update.active = patch.active;
  if (typeof patch.portal_enabled === "boolean")
    update.portal_enabled = patch.portal_enabled;
  if (typeof patch.notify_by_email === "boolean")
    update.notify_by_email = patch.notify_by_email;
  if (typeof patch.due_day_of_month === "number")
    update.due_day_of_month = patch.due_day_of_month;
  if (typeof patch.due_timezone === "string")
    update.due_timezone = patch.due_timezone.trim();

  return expectSingleId(
    supabase
      .from("clients")
      .update(update)
      .eq("id", clientId)
      .eq("user_id", user.id)
      .select("id")
      .single(),
    "Update succeeded but no row returned"
  );
}

export async function deleteClient(clientId: string) {
  assertUuid("clientId", clientId);

  const { supabase, user } = await requireUser();

  const { error } = await supabase
    .from("clients")
    .delete()
    .eq("id", clientId)
    .eq("user_id", user.id);

  if (error) throw error;
  return { id: clientId };
}

export async function listClientsWithProgress() {
  const { supabase, user } = await requireUser();

  const { data, error } = await supabase
    .from("clients_with_progress")
    .select(
      "id,name,email,active,portal_enabled,public_token,created_at,updated_at,due_day_of_month,due_timezone,required_total,required_received"
    )
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data ?? [];
}
